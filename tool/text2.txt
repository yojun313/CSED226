To handle multiple categorical columns with label encoding, such as `age_group` and `sex`, you can use separate `LabelEncoder` instances for each column. You can create a dictionary to map each column to its corresponding `LabelEncoder`. Here's how you can modify the `preprocess_data` function to do this:

```python
def preprocess_data(train_path, test_path):
    """
    학습 및 테스트 데이터를 전처리하는 함수.
    - 학습 데이터에서 결측치를 제거하고, 선택된 열들을 숫자로 인코딩.
    - 테스트 데이터에서 분석에 불필요한 열 제거.

    Parameters:
        train_path (str): 학습 데이터 파일 경로.
        test_path (str): 테스트 데이터 파일 경로.

    Returns:
        X_train (DataFrame): 학습 데이터의 특성(features).
        y_train (Series): 학습 데이터의 타겟 변수(labels).
        real_data (DataFrame): 테스트 데이터의 특성(features).
        label_encoders (dict): 각 열에 대해 숫자로 변환하는 인코더 객체들의 사전.
    """
    # 학습 데이터 로드 및 결측치 제거
    train_data = pd.read_csv(train_path)
    train_data = train_data.dropna()

    # 열을 숫자로 인코딩할 LabelEncoder 객체들 생성
    label_encoders = {}
    for column in ['sex', 'age_group']:  # 인코딩할 열들
        le = LabelEncoder()
        train_data[column] = le.fit_transform(train_data[column])
        label_encoders[column] = le

    # 타겟 변수 분리
    y_train = train_data['age_group']

    # 학습 데이터에서 타겟 및 비특성 열 제거
    X_train = train_data.drop(columns=['age_group', 'FastingBloodSugar'])

    # 테스트 데이터 로드 및 인코딩
    real_data = pd.read_csv(test_path)
    real_data = real_data.drop(columns=['FastingBloodSugar'])

    # 테스트 데이터에 동일한 인코딩 적용
    for column, le in label_encoders.items():
        if column in real_data.columns:
            real_data[column] = le.transform(real_data[column])

    return X_train, y_train, real_data, label_encoders
```

In this approach, we maintain a dictionary `label_encoders` that keeps track of each `LabelEncoder` specific to a column. This allows you to use the correct encoder to transform data both during training and on the real (test) dataset. You can use this dictionary later to decode the predicted labels in the `save_results` function if you need to reverse the encoding.

Make sure that when you decode the predictions in `save_results`, you use the appropriate encoder for the target variable (in this case, `age_group`). Here’s an updated version of `save_results` to handle this:

```python
def save_results(predictions, label_encoders, output_path):
    """
    모델 예측 결과를 저장하는 함수.
    - 예측된 숫자 값을 원래 라벨로 디코딩 후, 결과를 CSV로 저장.

    Parameters:
        predictions (array): 모델이 예측한 값.
        label_encoders (dict): 각 열에 대해 숫자 값을 라벨로 변환하는 인코더 객체들의 사전.
        output_path (str): 결과를 저장할 CSV 파일 경로.
    """
    # 숫자로 예측된 값을 라벨로 변환 (타겟은 age_group)
    real_pred_labels = label_encoders['age_group'].inverse_transform(predictions)

    # 결과를 ID와 age_group 형태의 데이터프레임으로 생성
    result_df = pd.DataFrame({
        'idx': range(len(real_pred_labels)),  # ID는 0부터 시작
        'age_group': real_pred_labels  # age_group 라벨
    })

    # 결과를 CSV 파일로 저장
    result_df.to_csv(output_path, index=False)
```

Remember to export and utilize the updated functions to ensure proper label encoding and decoding for all relevant categories in your datasets.